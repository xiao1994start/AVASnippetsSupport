{
  "cv2 模板匹配方法测试函数": {
    "prefix": ["cv2 def test_cv2_TM"],
    "body": [
      "def test_cv2_TM_gray(img, templ):",
      "    \"\"\"",
      "    OpenCV模板匹配方法测试(修改分辨率需要重新设置匹配目标)",
      "    测试模式:gray灰度模式",
      "    [一般情况:cv2.TM_CCOEFF_NORMED效果最佳,cv2.TM_CCORR_NORMED其次]",
      "    Args:",
      "        img (str | Path): 被匹配图像路径",
      "        template (str | Path): 匹配模板图像路径",
      "    \"\"\"",
      "    # 读取需匹配图像",
      "    img = cv2.imread(str(img))  # 读取需匹配图像",
      "    # 图像灰度",
      "    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  # *颜色空间转换[cv2.COLOR_BGR2GRAY:灰度模式]",
      "    # 读取匹配模板图像",
      "    templ = cv2.imread(str(templ), 0)  # 读取匹配模板图像",
      "    # 模板匹配方法列表",
      "    templateMethodNames = [",
      "        'TM_SQDIFF',  # *平方差匹配法[值越小匹配越好|对亮度变化敏感|完全匹配时为0]",
      "        # 计算模板与图像区域的平方差",
      "        # 公式: R(x,y) = Σ[T(x',y') - I(x+x',y+y')]²",
      "        # 最佳匹配: 最小值 (0表示完美匹配)",
      "        'TM_SQDIFF_NORMED',  # *归一化平方差匹配法[对图像亮度变化不敏感|结果在0-1之间,便于比较|最常用的方法之一]",
      "        # 平方差的归一化版本",
      "        # 公式: R(x,y) = Σ[T(x',y') - I(x+x',y+y')]² / √(ΣT(x',y')² • ΣI(x+x',y+y')²)",
      "        # 最佳匹配: 最小值 (0-1范围;0表示完美匹配)",
      "        'TM_CCORR',  # *相关匹配法[值越大匹配越好|对亮度变化敏感|亮区容易产生高值]",
      "        # 计算模板与图像区域的相关性",
      "        # 公式: R(x,y) = Σ[T(x',y') • I(x+x',y+y')]",
      "        # 最佳匹配: 最大值",
      "        'TM_CCORR_NORMED',  # *归一化相关匹配法[对亮度变化不敏感|结果在0-1之间|性能较好]",
      "        # 相关性的归一化版本",
      "        # 公式: R(x,y) = Σ[T(x',y') • I(x+x',y+y')] / √(ΣT(x',y')² • ΣI(x+x',y+y')²)",
      "        # 最佳匹配: 最大值 (0-1范围;1表示完美匹配)",
      "        'TM_CCOEFF',  # *相关系数匹配法[考虑均值,对亮度变化不敏感|值域为实数,可能为负|能处理模板与图像亮度不一致的情况]",
      "        # 计算模板与图像区域的相关系数",
      "        # 公式: R(x,y) = Σ[T'(x',y') • I'(x+x',y+y')]",
      "        # 其中 T' = T - T.mean(), I' = I - I.mean()",
      "        # 最佳匹配: 最大值",
      "        'TM_CCOEFF_NORMED',  # *归一化相关系数匹配法[最常用的方法|对亮度变化不敏感|结果在-1到1之间|抗干扰能力强]",
      "        # 相关系数的归一化版本",
      "        # 公式: R(x,y) = Σ[T'(x',y') • I'(x+x',y+y')] / √(ΣT'(x',y')² • ΣI'(x+x',y+y')²)",
      "        # 最佳匹配: 最大值 (-1到1范围;1表示完美匹配)",
      "    ]",
      "    for method_name in templateMethodNames:",
      "        method = getattr(cv2, method_name)",
      "        print(f'[bold]匹配方法:{method}-{method_name}')",
      "        # 模板匹配",
      "        res = cv2.matchTemplate(img_gray, templ, method)",
      "        method_img = img.copy()",
      "        # # *获取匹配结果:最小值, 最大值, 最小值坐标, 最大值坐标",
      "        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)",
      "        top_left = max_loc",
      "        bottom_right = (top_left[0] + templ.shape[1], top_left[1] + templ.shape[0])",
      "        width = bottom_right[0] - top_left[0]",
      "        height = bottom_right[1] - top_left[1]",
      "        cv2.rectangle(method_img, top_left, bottom_right, (0, 0, 255), 2)  # *绘制矩形:(0, 0, 255)-颜色(BGR); 2-线宽",
      "        method_img = cv2.resize(method_img, (0, 0), fx=0.5, fy=0.5)  # *缩放图片:cv2.imread()读取的图像对象;(0, 0)不直接指定尺寸;fx/fy缩放比例因子",
      "        cv2.imshow(f'{method_name}=>{top_left}:{bottom_right}[_{width}|{height}]', method_img)  # *显示 cv2.imread() 读取对象图片",
      "        print(f'匹配结果矩阵中的\\t最小值={min_val};\\t最大值={max_val};')",
      "        print(f'匹配结果矩阵中的\\t最小值坐标={min_loc};\\t最大值坐标={max_loc};')",
      "        cv2.waitKey(0)  # *图像显示时间函数(0 为无限时间的显示函数)",
      "        cv2.destroyAllWindows()  # *按下任意键便可关闭窗口",
      "    return True",
      ""
    ],
    "description": ["cv2 模板匹配方法测试函数"]
  }
}
