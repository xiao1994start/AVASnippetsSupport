{
  "pyinstaller 打包 python -> exe": {
    "prefix": ["import pyinstaller =commmand", "im pyinstaller =commmand"],
    "body": [
      "import os",
      "import shutil",
      "import subprocess",
      "import sys",
      "from datetime import datetime",
      "from pathlib import Path",
      "",
      "from PyInstaller.__main__ import run",
      "from rich import print",
      "",
      "# [https://blog.csdn.net/weixin_44809381/article/details/120783843]",
      "",
      "",
      "# *要打包的入口文件",
      "app = Path(Path(__file__).parent, 'main.py')",
      "# *当前时间戳",
      "now = datetime.now().strftime('%Y%m%d')",
      "# *打包后的文件名",
      "app_name = f'My_App{now}'",
      "# *打包后的图标",
      "# app_icon = Path(Path(__file__).parent, 'ico.ico')",
      "# *打包生成目录",
      "bin_path = Path(Path(__file__).parent, '__bin__')",
      "",
      "",
      "command = [",
      "    f'{app}',  # *要打包的入口文件",
      "    f'--name={app_name}',  # *打包后的文件名",
      "    # f'--icon={app_icon}',  # *打包后的图标",
      "    '--onefile',  # *打包成一个文件",
      "    '--runtime-tmpdir=.',  # *指定解压临时文件目录(退出清理)[当前文件夹下:./_EMIxxxxxx临时文件]",
      "    f'--workpath={Path(bin_path, \"build\")}',  # 打包时临时文件存放路径",
      "    f'--distpath={Path(bin_path, \"dist\")}',  # 打包后文件存放路径",
      "    f'--specpath={bin_path}',  # 存储生成的 .spec 文件的文件夹(默认:SPECPATH当前路径; --add-data时会影响索引路径)",
      "    # '--windowed',  # 无控制台窗口(需要使用input语句时,要打开控制台窗口)",
      "    '--log-level=INFO',  # 编译时控制台信息的详细程度(默认值: INFO): TRACE | DEBUG | INFO | WARN | DEPRECATION | ERROR | FATAL",
      "    '--clean',  # 清理之前的打包文件",
      "    '--noconfirm',  # 覆盖输出目录中的原有内容(默认值: SPECPATH/dist/SPECNAME), 不请求确认",
      "    # TODO 打包资源文件 --add-data=资源路径;目标路径[使用 Path(__file__).parent.resolve() 定位脚本位置后, 在加入子路径进行调用]",
      "    f'--add-data={Path(Path(__file__).parent, \"utils\", \"*\")}{os.pathsep}utils',",
      "    # !ModuleNotFoundError: No module named 'rich._unicode_data.unicode17-0-0'",
      "    # ![PYI-13472:ERROR] Failed to execute script 'main' due to unhandled exception!",
      "    # *显式要求 PyInstaller 收集 rich 库的所有相关依赖[--collect-all = ...](此选项可以多次使用)",
      "    '--collect-all=rich',",
      "    # !具体根据 `importlib.metadata.PackageNotFoundError: No package metadata was found for 'readchar'` 运行报错分析",
      "    # *手动添加模块 --copy-metadata=PACKAGENAME(需要手动添加的模块名称, 如:使用inquirer需要`--copy-metadata=readchar`手动添加`readchar`模块)",
      "    # '--copy-metadata=readchar',",
      "]",
      "",
      "",
      "if bin_path.exists.exists(follow_symlinks=False):",
      "    try:",
      "        shutil.rmtree(bin_path)",
      "    except PermissionError:",
      "        subprocess.run(f'rd /S /Q \"{bin_path}\"', shell=True)",
      "    except Exception as error:",
      "        print(f'[red]错误类型:[/]{type(error)}')",
      "        print(f'[red]错误信息:[/]{error}')",
      "        sys.exit()",
      "",
      "",
      "run(command)",
      "",
      "",
      "# *打开打包后的文件夹",
      "os.startfile(Path(bin_path, 'dist'))",
      "",
      "",
      "subprocess.run('cls', shell=True) if os.name == 'nt' else subprocess.run('clear')",
      "print('[bold green]>> 打包完成 <<[/]')",
      ""
    ],
    "description": "pyinstaller 打包 python -> exe"
  },
  "pyinstaller 打包独立exe": {
    "prefix": ["pyinstaller 2 bin", "pyinstaller==bin"],
    "body": [
      "import os",
      "import shutil",
      "import subprocess",
      "import zipfile",
      "from pathlib import Path",
      "",
      "from rich import print",
      "",
      "",
      "def pyi(py_file: str | Path, py_release: str | Path):",
      "    # TODO:PyInstaller 打包器",
      "",
      "    # *配置环境",
      "    py_embed = Path(Path(__file__).parent.resolve(), 'python-embed')",
      "    py_embed_zip = Path(Path(__file__).parent.resolve(), 'utils', 'python-embed.zip')",
      "    if not py_embed.exists():",
      "        with zipfile.ZipFile(py_embed_zip, 'r') as zip_f:",
      "            zip_f.extractall(py_embed)  # 解压到目录",
      "    py_embed_env = list(map(str, [Path(py_embed), Path(py_embed, 'Scripts')]))",
      "    pyinstaller_path = Path(py_embed, 'Scripts', 'pyinstaller.exe')",
      "    os.environ['PATH'] = f'{\";\".join(py_embed_env)};{os.getenv(\"PATH\")}'",
      "    print('[bold green]Python环境检查[/]')",
      "    subprocess.run('python --version')",
      "    print('[bold green]Pip环境检查[/]')",
      "    subprocess.run('python -m pip --version')",
      "    print('[bold green]PyInstaller环境检查[/]')",
      "    subprocess.run(f'python \"{pyinstaller_path}\" -v')",
      "",
      "    # *打包参数",
      "    pyi_file = Path(py_file)",
      "    pyi_dir = Path(pyi_file.parent.resolve(), '__bin__')",
      "    pyi_build = Path(pyi_dir, 'build')",
      "    pyi_release = Path(py_release)",
      "",
      "    # *打包命令",
      "    pyi_args = [",
      "        '-F',",
      "        f'\"{pyi_file}\"',",
      "        f'-n {pyi_file.stem}',",
      "        '--runtime-tmpdir .',",
      "        f'--workpath \"{pyi_build}\"',",
      "        f'--distpath \"{pyi_release}\"',",
      "        f'--specpath \"{pyi_dir}\"',",
      "        '--clean',",
      "        '--noconfirm',",
      "        '--log-level ERROR',",
      "    ]",
      "",
      "    pyi_arg = ' '.join(pyi_args)",
      "    # TODO:使用PyInstaller打包",
      "    subprocess.run(f'python \"{pyinstaller_path}\" {pyi_arg}')",
      "",
      "    # *清理缓存",
      "    if pyi_dir.exists():",
      "        try:",
      "            shutil.rmtree(str(pyi_dir))",
      "        except PermissionError:",
      "            subprocess.run(f'rd /S /Q \"{pyi_dir}\"', shell=True)",
      "        except Exception as error:",
      "            print(f'错误类型:{type(error)}')",
      "            print(f'错误信息:{error}')",
      "            raise error",
      "",
      "",
      "if __name__ == '__main__':",
      "    # pyi()",
      "    ...",
      ""
    ],
    "description": "pyinstaller 打包独立exe"
  }
}
